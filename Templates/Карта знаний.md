# Карта знаний: <% tp.file.folder() %>

```dataviewjs
// Получаем текущую папку, в которой находится этот файл
const currentFolder = dv.current().file.folder;

// Получаем все страницы из этой папки, исключая сам файл карты
const pages = dv.pages(`"${currentFolder}"`)
    .where(p => p.file.name !== dv.current().file.name);

// Функция для создания иерархии из плоского списка тегов
function buildHierarchy(pages) {
    // Структура узла: { name: "TagName", files: [links], children: { "SubTag": Node... } }
    const root = { name: "root", files: [], children: {} };

    for (const page of pages) {
        // Получаем теги. В Dataview это массив строк (с #).
        let rawTags = page.file.tags || [];

        // Преобразуем (если это Set/Proxy) в массив
        if (rawTags.values) rawTags = Array.from(rawTags);

        // Убираем символ #
        let cleanTags = rawTags.map(t => t.replace("#", ""));

        // Если тегов нет - в корень
        if (cleanTags.length === 0) {
            root.files.push(page.file.link);
            continue;
        }

        let currentNode = root;

        // Идем по иерархии тегов (Tag1 -> Tag2 -> Tag3)
        // Предполагаем, что порядок тегов в списке определяет вложенность
        for (const tag of cleanTags) {
            if (!currentNode.children[tag]) {
                currentNode.children[tag] = { name: tag, files: [], children: {} };
            }
            currentNode = currentNode.children[tag];
        }

        // Добавляем ссылку на файл в узел ПОСЛЕДНЕГО тега
        currentNode.files.push(page.file.link);
    }
    return root;
}

// Рекурсивная функция отрисовки дерева
function renderTree(node, level = 0) {
    // Выводим файлы на текущем уровне (если они есть)
    // Обычно файлы находятся в конечных узлах, но могут быть и промежуточные
    if (node.files && node.files.length > 0) {
        for (const fileLink of node.files) {
            // Файлы отображаем с отступом чуть больше, чем у родительского тега
            // Или на том же уровне, но как листья
            dv.paragraph(`${"  ".repeat(level)}- ${fileLink}`);
        }
    }

    // Сортируем дочерние теги по алфавиту
    const sortedTags = Object.keys(node.children).sort();

    for (const tagName of sortedTags) {
        const childNode = node.children[tagName];
        const indent = "  ".repeat(level);

        // Выводим тег
        dv.paragraph(`${indent}- **${tagName}**`);

        // Рекурсивно выводим содержимое этого тега (его файлы и подтеги)
        renderTree(childNode, level + 1);
    }
}

const tree = buildHierarchy(pages);

if (pages.length === 0) {
    dv.paragraph("В этой папке пока нет заметок для отображения.");
} else {
    renderTree(tree);

    // Отдельно выведем файлы без тегов, если они попали в корень
    if (tree.files.length > 0) {
        dv.header(4, "Без тегов");
        for (const fileLink of tree.files) {
             dv.paragraph(`- ${fileLink}`);
        }
    }
}
```
